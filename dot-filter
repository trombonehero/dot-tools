#!env python

import argparse
import collections
import itertools
import re
import sys

argparser = argparse.ArgumentParser(description=
'''Filter paths from a .dot graph that do not end in specified nodes.''')

files = argparser.add_argument_group('Files')
files.add_argument('file', help='.dot file to filter')
files.add_argument('-o', '--outfile', metavar='OUT', default='-',
	help='Filtered output (.dot file)')

functions = argparser.add_argument_group('Functions')
functions.add_argument('targets', nargs='*', help='''
		Include these nodes and the transitive closure of their predecessors in
		the filtered graph''')
functions.add_argument('--ignore', metavar='node', help='''
		Always ignore these nodes (e.g. the "external node" that is always
		generated by LLVM's opt -dot-callgraph)''',
		nargs='*', default=['external node'])

syscall_groups = [
	('file', 'Add file-related syscalls (open, mmap, stat...) to target list',
		[
			'open', 'openat', 'mmap',
			'stat', 'fstat', 'fstatat', 'lstat', 'fstatfs'
			'close'
		]
	),
	('io', 'Add IO-related syscalls (read, write, aio_*...) to target list',
		[
			'read', 'write',
			'ioctl',
			'aio_read', 'aio_write', 'aio_cancel', 'aio_suspend',
			'aio_error', 'aio_return', 'aio_waitcomplete'
		]
	),
	('kernel', 'Add kldload, syctl, etc. to target list',
		[
			'kldfind', 'kldstat', 'kldsym', 'kldload', 'kldunload',
			'modfind', 'modfnext', 'modnext',
			'sysctl'
		]
	),
	('proc', 'Add fork, execve... to target list',
		[
			'fork', 'vfork', 'rfork',
			'execve', 'fexecve', 'exit', '_exit'
		]
	)
]

for (flag, message, syscalls) in syscall_groups:
	functions.add_argument('--%s' % flag, action='store_true', help=message)

args = argparser.parse_args()

targets = dict(zip(args.targets,
	itertools.cycle([ '/dark27/%d' % i for i in range(1,8) ])
))

scheme = 'pastel19'
colours = itertools.cycle([ '/%s/%d' % (scheme, i) for i in range(1,10) ])

for (flag, message, syscalls) in syscall_groups:
	group_colour = colours.next()
	if args.__getattribute__(flag):
		for call in syscalls:
			targets[call] = group_colour

if len(targets) == 0: argparser.error('No target nodes specified')



# Regular expressions for nodes and edges.
labeled_node = re.compile('\s*[A-Za-z0-9_]+\s\[.*label.*\];$')
edge = re.compile('\s*[A-Za-z0-9_]+\s*->\s*[A-Za-z0-9_]+')

# Nodes that we definitely want to keep.
keep = {}

# Nodes that we want to ignore.
ignore = []

# Read in the graph.
def blank_node(): return { 'from': set() }
nodes = collections.defaultdict(blank_node)

for line in open(args.file, 'r'):
	if labeled_node.match(line):
		(name, attributes) = line.split(' ', 1)
		name = name.strip()
		attributes = attributes[1:-2]
		attributes = dict([ x.split('=') for x in attributes.split(',') ])

		assert re.match('"{.*}"', attributes['label'])
		attributes['label'] = attributes['label'][2:-3]
		attributes['name'] = name

		if attributes['label'] in args.ignore: ignore.append(name)
		if attributes['label'] in targets:
			attributes.update({
					'fillcolor': targets[attributes['label']],
					'style':     'bold,filled'
				})
			keep[name] = nodes[name]

		nodes[name].update(attributes)

	elif edge.match(line):
		(begin, end) = [ nodes[s.strip()] for s in line[:-2].split('->') ]
		end['from'].add(begin['name'])


# Find all ancestors of a node (that we don't already know about).
def get_ancestors(node, keep):
	keep[node['name']] = node
	for predecessor in node['from']:
		node = nodes[predecessor]
		(name, label) = (node['name'], node['label'])
		if name in keep: continue
		if name in ignore: continue
		keep[name] = node
		get_ancestors(node, keep)

	return keep

for target in keep.values(): get_ancestors(target, keep)


def attribute_list(attrs):
	return '[%s]' % ','.join([ '%s="%s"' % (a,attrs[a]) for a in attrs])


# Write the filtered callgraph.
if args.outfile == '-': out = sys.stdout
else: out = open(args.outfile, 'w')

out.write('digraph {\n')

for (name,node) in keep.items():
	# Ignore attributes created above.
	attrs = dict([ (a, node[a]) for a in node if a not in [ 'from', 'name' ] ])
	out.write('\t%s%s;\n' % (name, attribute_list(attrs)))

	for pred in node['from']:
		if pred in ignore: continue

		color = node['fillcolor'] if 'fillcolor' in node else '#00000033'
		attrs = attribute_list({ 'color': color })
		out.write('\t%s -> %s%s;\n' % (nodes[pred]['name'], name, attrs))

out.write('}\n')

